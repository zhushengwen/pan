'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.promisify = promisify;
exports.waitForEvent = waitForEvent;
exports.waitForNonEvent = waitForNonEvent;
exports.delay = delay;
exports.capitalizeFirstLetter = capitalizeFirstLetter;
exports.makeMethodName = makeMethodName;

var _checks = require('@carnesen/checks');

function promisify(func, options) {
  (0, _checks.throwIfNotFunction)(func, 'func');
  options = options || {};
  return function () {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return new Promise(function (resolve, reject) {
      func.apply(undefined, args.concat([function (err) {
        for (var _len2 = arguments.length, rets = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          rets[_key2 - 1] = arguments[_key2];
        }

        if (err) {
          if (options.rejectArray) {
            reject([err].concat(rets));
          } else {
            reject(err);
          }
        } else {
          if (options.resolveArray) {
            resolve([].concat(rets));
          } else {
            resolve([].concat(rets)[0]);
          }
        }
      }]));
    });
  };
}

function attachTimedEventCallback(_ref) {
  var event = _ref.event,
      timeout = _ref.timeout;

  (0, _checks.throwIfNotFunction)(event.emitter.once, 'event.emitter.once');
  (0, _checks.throwIfNotFunction)(event.emitter.removeListener, 'event.emitter.removeListener');
  (0, _checks.throwIfNotNonEmptyString)(event.name, 'event.name');
  (0, _checks.throwIfNotFunction)(event.callback, 'event.callback');
  (0, _checks.throwIfNotFunction)(timeout.callback, 'timeout.callback');

  if ((0, _checks.isDefined)(timeout.interval)) {
    (0, _checks.throwIfNotPositiveNumber)(timeout.interval, 'timeout.interval');
  }

  var timeoutId = void 0;

  function eventHandler() {
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
    event.callback.apply(event, arguments);
  }

  function timeoutHandler() {
    event.emitter.removeListener(event.name, eventHandler);
    timeout.callback();
  }

  if (timeout.interval) {
    timeoutId = setTimeout(timeoutHandler, timeout.interval);
  }

  event.emitter.once(event.name, eventHandler);
}

function waitForEvent(emitter, name, interval) {
  return new Promise(function (resolve, reject) {
    attachTimedEventCallback({
      event: {
        emitter: emitter,
        name: name,
        callback: function callback(value) {
          resolve(value);
        }
      },
      timeout: {
        interval: interval,
        callback: function callback() {
          var message = 'Timed out after ' + interval + ' milliseconds waiting for event "' + name + '"';
          reject(new Error(message));
        }
      }
    });
  });
}

function waitForNonEvent(emitter, name, interval) {
  return new Promise(function (resolve, reject) {
    attachTimedEventCallback({
      event: {
        emitter: emitter,
        name: name,
        callback: function callback(value) {
          var err = new Error('Emitter emitted event "' + name + '"');
          err.value = value;
          reject(err);
        }
      },
      timeout: {
        interval: interval,
        callback: resolve
      }
    });
  });
}

function delay(interval) {
  var startTime = Date.now();
  return new Promise(function (resolve) {
    return setTimeout(function () {
      return resolve(Date.now() - startTime);
    }, interval);
  });
}

function capitalizeFirstLetter(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}

function makeMethodName(string) {
  var parts = string.split(/[ -]/).map(function (part) {
    return part.toLowerCase();
  });
  return '' + parts[0] + parts.slice(1).map(capitalizeFirstLetter).join('');
}